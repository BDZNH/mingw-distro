diff -aurN gcc-4.7.1/gcc/c-family/c-common.c gcc-4.7.1-fixed/gcc/c-family/c-common.c
--- gcc-4.7.1/gcc/c-family/c-common.c	2012-02-13 12:12:54 -0800
+++ gcc-4.7.1-fixed/gcc/c-family/c-common.c	2012-06-17 16:18:39 -0700
@@ -8724,6 +8724,7 @@
   {CPP_W_NORMALIZE,			OPT_Wnormalized_},
   {CPP_W_INVALID_PCH,			OPT_Winvalid_pch},
   {CPP_W_WARNING_DIRECTIVE,		OPT_Wcpp},
+  {CPP_W_LITERAL_SUFFIX,		OPT_Wliteral_suffix},
   {CPP_W_NONE,				0}
 };
 
diff -aurN gcc-4.7.1/gcc/c-family/c-opts.c gcc-4.7.1-fixed/gcc/c-family/c-opts.c
--- gcc-4.7.1/gcc/c-family/c-opts.c	2012-01-18 05:10:40 -0800
+++ gcc-4.7.1-fixed/gcc/c-family/c-opts.c	2012-06-17 16:18:39 -0700
@@ -475,6 +475,10 @@
       cpp_opts->warn_invalid_pch = value;
       break;
 
+    case OPT_Wliteral_suffix:
+      cpp_opts->warn_literal_suffix = value;
+      break;
+
     case OPT_Wlong_long:
       cpp_opts->cpp_warn_long_long = value;
       break;
diff -aurN gcc-4.7.1/gcc/c-family/c.opt gcc-4.7.1-fixed/gcc/c-family/c.opt
--- gcc-4.7.1/gcc/c-family/c.opt	2012-02-06 02:31:18 -0800
+++ gcc-4.7.1-fixed/gcc/c-family/c.opt	2012-06-17 16:18:39 -0700
@@ -449,6 +449,10 @@
 C ObjC Var(warn_jump_misses_init) Init(-1) Warning
 Warn when a jump misses a variable initialization
 
+Wliteral-suffix
+C++ ObjC++ Warning
+Warn when a string or character literal is followed by a ud-suffix which does not begin with an underscore.
+
 Wlogical-op
 C ObjC C++ ObjC++ Var(warn_logical_op) Init(0) Warning 
 Warn when a logical operator is suspiciously always evaluating to true or false
diff -aurN gcc-4.7.1/gcc/doc/invoke.texi gcc-4.7.1-fixed/gcc/doc/invoke.texi
--- gcc-4.7.1/gcc/doc/invoke.texi	2012-06-04 13:30:59 -0700
+++ gcc-4.7.1-fixed/gcc/doc/invoke.texi	2012-06-17 16:18:39 -0700
@@ -197,8 +197,8 @@
 -fno-default-inline  -fvisibility-inlines-hidden @gol
 -fvisibility-ms-compat @gol
 -Wabi  -Wconversion-null  -Wctor-dtor-privacy @gol
--Wdelete-non-virtual-dtor -Wnarrowing -Wnoexcept @gol
--Wnon-virtual-dtor  -Wreorder @gol
+-Wdelete-non-virtual-dtor -Wliteral-suffix -Wnarrowing @gol
+-Wnoexcept -Wnon-virtual-dtor  -Wreorder @gol
 -Weffc++  -Wstrict-null-sentinel @gol
 -Wno-non-template-friend  -Wold-style-cast @gol
 -Woverloaded-virtual  -Wno-pmf-conversions @gol
@@ -2413,6 +2413,30 @@
 base class does not have a virtual destructor.  This warning is enabled
 by @option{-Wall}.
 
+@item -Wliteral-suffix @r{(C++ and Objective-C++ only)}
+@opindex Wliteral-suffix
+@opindex Wno-literal-suffix
+Warn when a string or character literal is followed by a ud-suffix which does
+not begin with an underscore.  As a conforming extension, GCC treats such
+suffixes as separate preprocessing tokens in order to maintain backwards
+compatibility with code that uses formatting macros from @code{<inttypes.h>}.
+For example:
+
+@smallexample
+#define __STDC_FORMAT_MACROS
+#include <inttypes.h>
+#include <stdio.h>
+
+int main() @{
+  int64_t i64 = 123;
+  printf("My int64: %"PRId64"\n", i64);
+@}
+@end smallexample
+
+In this case, @code{PRId64} is treated as a separate preprocessing token.
+
+This warning is enabled by default.
+
 @item -Wnarrowing @r{(C++ and Objective-C++ only)}
 @opindex Wnarrowing
 @opindex Wno-narrowing
diff -aurN gcc-4.7.1/gcc/testsuite/g++.dg/cpp0x/Wliteral-suffix.C gcc-4.7.1-fixed/gcc/testsuite/g++.dg/cpp0x/Wliteral-suffix.C
--- gcc-4.7.1/gcc/testsuite/g++.dg/cpp0x/Wliteral-suffix.C	1969-12-31 16:00:00 -0800
+++ gcc-4.7.1-fixed/gcc/testsuite/g++.dg/cpp0x/Wliteral-suffix.C	2012-06-17 16:18:39 -0700
@@ -0,0 +1,29 @@
+// { dg-do run }
+// { dg-options "-std=c++0x" }
+
+// Make sure -Wliteral-suffix is enabled by default and
+// triggers as expected.
+
+#define BAR "bar"
+#define PLUS_ONE + 1
+
+#include <cstdint>
+#include <cassert>
+
+
+void
+test()
+{
+  char c = '3'PLUS_ONE;	  // { dg-warning "invalid suffix on literal" }
+  char s[] = "foo"BAR;	  // { dg-warning "invalid suffix on literal" }
+
+  assert(c == '4');
+  assert(s[3] != '\0');
+  assert(s[3] == 'b');
+}
+
+int
+main()
+{
+  test();
+}
diff -aurN gcc-4.7.1/libcpp/include/cpplib.h gcc-4.7.1-fixed/libcpp/include/cpplib.h
--- gcc-4.7.1/libcpp/include/cpplib.h	2011-12-20 12:44:13 -0800
+++ gcc-4.7.1-fixed/libcpp/include/cpplib.h	2012-06-17 16:18:39 -0700
@@ -427,6 +427,10 @@
   /* Nonzero for C++ 2011 Standard user-defnied literals.  */
   unsigned char user_literals;
 
+  /* Nonzero means warn when a string or character literal is followed by a
+     ud-suffix which does not beging with an underscore.  */
+  unsigned char warn_literal_suffix;
+
   /* Holds the name of the target (execution) character set.  */
   const char *narrow_charset;
 
@@ -906,7 +910,8 @@
   CPP_W_CXX_OPERATOR_NAMES,
   CPP_W_NORMALIZE,
   CPP_W_INVALID_PCH,
-  CPP_W_WARNING_DIRECTIVE
+  CPP_W_WARNING_DIRECTIVE,
+  CPP_W_LITERAL_SUFFIX
 };
 
 /* Output a diagnostic of some kind.  */
diff -aurN gcc-4.7.1/libcpp/init.c gcc-4.7.1-fixed/libcpp/init.c
--- gcc-4.7.1/libcpp/init.c	2011-12-20 12:44:13 -0800
+++ gcc-4.7.1-fixed/libcpp/init.c	2012-06-17 16:18:39 -0700
@@ -175,6 +175,7 @@
   CPP_OPTION (pfile, warn_variadic_macros) = 1;
   CPP_OPTION (pfile, warn_builtin_macro_redefined) = 1;
   CPP_OPTION (pfile, warn_normalize) = normalized_C;
+  CPP_OPTION (pfile, warn_literal_suffix) = 1;
 
   /* Default CPP arithmetic to something sensible for the host for the
      benefit of dumb users like fix-header.  */
diff -aurN gcc-4.7.1/libcpp/lex.c gcc-4.7.1-fixed/libcpp/lex.c
--- gcc-4.7.1/libcpp/lex.c	2011-12-07 14:05:59 -0800
+++ gcc-4.7.1-fixed/libcpp/lex.c	2012-06-17 16:18:39 -0700
@@ -1491,14 +1491,30 @@
 
   if (CPP_OPTION (pfile, user_literals))
     {
+      /* According to C++11 [lex.ext]p10, a ud-suffix not starting with an
+	 underscore is ill-formed.  Since this breaks programs using macros
+	 from inttypes.h, we generate a warning and treat the ud-suffix as a
+	 separate preprocessing token.  This approach is under discussion by
+	 the standards committee, and has been adopted as a conforming
+	 extension by other front ends such as clang. */
+      if (ISALPHA (*cur))
+	{
+	  // Raise a warning, but do not consume subsequent tokens.
+	  if (CPP_OPTION (pfile, warn_literal_suffix))
+	    cpp_warning_with_line (pfile, CPP_W_LITERAL_SUFFIX,
+				   token->src_loc, 0,
+				   "invalid suffix on literal; C++11 requires "
+				   "a space between literal and identifier");
+	}
       /* Grab user defined literal suffix.  */
-      if (ISIDST (*cur))
+      else if (*cur == '_')
 	{
 	  type = cpp_userdef_string_add_type (type);
 	  ++cur;
+
+	  while (ISIDNUM (*cur))
+	    ++cur;
 	}
-      while (ISIDNUM (*cur))
-	++cur;
     }
 
   pfile->buffer->cur = cur;
@@ -1606,15 +1622,31 @@
 
   if (CPP_OPTION (pfile, user_literals))
     {
+      /* According to C++11 [lex.ext]p10, a ud-suffix not starting with an
+	 underscore is ill-formed.  Since this breaks programs using macros
+	 from inttypes.h, we generate a warning and treat the ud-suffix as a
+	 separate preprocessing token.  This approach is under discussion by
+	 the standards committee, and has been adopted as a conforming
+	 extension by other front ends such as clang. */
+      if (ISALPHA (*cur))
+	{
+	  // Raise a warning, but do not consume subsequent tokens.
+	  if (CPP_OPTION (pfile, warn_literal_suffix))
+	    cpp_warning_with_line (pfile, CPP_W_LITERAL_SUFFIX,
+				   token->src_loc, 0,
+				   "invalid suffix on literal; C++11 requires "
+				   "a space between literal and identifier");
+	}
       /* Grab user defined literal suffix.  */
-      if (ISIDST (*cur))
+      else if (*cur == '_')
 	{
 	  type = cpp_userdef_char_add_type (type);
 	  type = cpp_userdef_string_add_type (type);
           ++cur;
+
+	  while (ISIDNUM (*cur))
+	    ++cur;
 	}
-      while (ISIDNUM (*cur))
-	++cur;
     }
 
   pfile->buffer->cur = cur;
